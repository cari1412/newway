import axios from 'axios';
import { calculateRetailPrice } from '@/utils/price';

const API_URL = 'https://api.sexystyle.site';

export interface Package {
  id: string;
  name: string;
  data: string;
  validity: string;
  price: number;
  retailPrice?: number; // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–µ –¥–ª—è —Ä–æ–∑–Ω–∏—á–Ω–æ–π —Ü–µ–Ω—ã
  location: string[];
  description: string;
  features: string[];
  smsStatus: number;
  operatorList: OperatorInfo[];
}

export interface OperatorInfo {
  operatorName: string;
  networkType: string;
}

export interface TonPayment {
  address: string;
  amount: string;
  payload: string;
}

interface APIResponse<T> {
  success: boolean;
  errorCode: string | null;
  errorMsg: string | null;
  data?: T;
  obj?: {
    packageList?: T;
  };
}

const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json'
  },
  timeout: 15000
});

// –ö—ç—à –¥–ª—è –ø–∞–∫–µ—Ç–æ–≤
let packagesCache: { [key: string]: Package[] } = {};

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤
apiClient.interceptors.request.use(
  (config) => {
    console.log('üöÄ Request:', {
      url: config.url,
      method: config.method,
      params: config.params,
      data: config.data
    });
    return config;
  },
  (error) => {
    console.error('‚ùå Request Error:', error);
    return Promise.reject(error);
  }
);

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–æ–≤
apiClient.interceptors.response.use(
  (response) => {
    console.log('‚úÖ Response:', {
      url: response.config.url,
      status: response.status,
      data: response.data
    });
    return response;
  },
  (error) => {
    console.error('‚ùå Response Error:', {
      url: error.config?.url,
      message: error.message,
      status: error.response?.status,
      data: error.response?.data
    });
    return Promise.reject(error);
  }
);

export const api = {
  async getPackages(location?: string): Promise<Package[]> {
    try {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
      const cacheKey = location || 'all';
      if (packagesCache[cacheKey]) {
        console.log('Returning cached packages for:', cacheKey);
        return packagesCache[cacheKey];
      }

      const response = await apiClient.post<APIResponse<Package[]>>('/api/v1/open/package/list', {
        locationCode: location || '',
        type: 'BASE'
      });

      if (!response.data.success) {
        throw new Error(response.data.errorMsg || 'Failed to fetch packages');
      }

      let packages: Package[] = [];
      if (response.data.obj?.packageList) {
        packages = response.data.obj.packageList;
      } else if (response.data.data) {
        packages = response.data.data;
      }

      // –î–æ–±–∞–≤–ª—è–µ–º —Ä–æ–∑–Ω–∏—á–Ω—ã–µ —Ü–µ–Ω—ã
      const packagesWithRetail = packages.map(pkg => ({
        ...pkg,
        retailPrice: calculateRetailPrice(pkg.price / 100) * 100 // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Ü–µ–Ω—Ç—ã –∏ –æ–±—Ä–∞—Ç–Ω–æ
      }));

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
      packagesCache[cacheKey] = packagesWithRetail;

      return packagesWithRetail;
    } catch (error) {
      console.error('Failed to fetch packages:', error);
      throw error;
    }
  },

  async createOrder(transactionId: string, packageCode: string): Promise<{orderNo: string}> {
    try {
      const response = await apiClient.post<APIResponse<{orderNo: string}>>('/api/v1/open/esim/order', {
        transactionId,
        packageInfoList: [{
          packageCode,
          count: 1
        }]
      });

      if (!response.data.success || !response.data.data) {
        throw new Error(response.data.errorMsg || 'Failed to create order');
      }

      return response.data.data;
    } catch (error) {
      console.error('Failed to create order:', error);
      throw error;
    }
  },

  async getOrderStatus(orderNo: string): Promise<{status: string; payment: boolean}> {
    try {
      const response = await apiClient.get<APIResponse<{status: string; payment: boolean}>>(`/api/v1/open/orders/${orderNo}`);

      if (!response.data.success || !response.data.data) {
        throw new Error(response.data.errorMsg || 'Failed to get order status');
      }

      return response.data.data;
    } catch (error) {
      console.error('Failed to get order status:', error);
      throw error;
    }
  },

  async createPayment(transactionId: string, amount: number, packageId: string): Promise<TonPayment> {
    try {
      // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ amount –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
      const formattedAmount = Math.round(amount); // –£–±–∏—Ä–∞–µ–º –¥–µ—Å—è—Ç–∏—á–Ω—ã–µ –∑–Ω–∞–∫–∏, —Ç–∞–∫ –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ–º –≤ —Ü–µ–Ω—Ç–∞—Ö
      
      const response = await apiClient.post<APIResponse<TonPayment>>('/api/v1/open/payments/create', {
        transactionId,
        amount: formattedAmount.toString(),
        packageId
      });

      if (!response.data.success || !response.data.data) {
        throw new Error(response.data.errorMsg || 'Failed to create payment');
      }

      return response.data.data;
    } catch (error) {
      console.error('Failed to create payment:', error);
      throw error;
    }
  },

  async verifyPayment(transactionId: string): Promise<boolean> {
    try {
      const response = await apiClient.post<APIResponse<{verified: boolean}>>('/api/v1/open/payments/verify', {
        transactionId
      });

      if (!response.data.success) {
        throw new Error(response.data.errorMsg || 'Failed to verify payment');
      }

      return response.data.data?.verified || false;
    } catch (error) {
      console.error('Failed to verify payment:', error);
      throw error;
    }
  },

  // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞
  clearCache(): void {
    packagesCache = {};
    console.log('Packages cache cleared');
  }
};